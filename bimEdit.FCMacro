#!/usr/bin/env python3 
# -*- coding: utf-8 -*-

## Explain this...

import FreeCAD, FreeCADGui, Draft, math, DraftGui
from DraftGui import todo, translate, utf8_decode
from FreeCAD import Vector
from DraftTools import Modifier, msg, selectObject, plane, \
        getPoint, redraw3DView, hasMod, MODALT, DraftVecUtils
from DraftTrackers import Tracker, ghostTracker, arcTracker
import re
from pivy import coin
from pivy.coin import *

### Utilities ###

normalizeNormal = lambda obj: obj.Normal if obj.Normal != App.Vector(0,0,0) \
        else App.Vector(0,0,1)

pickSelection = lambda sel, sel_type: \
        [o for o in sel if o.selectionType == sel_type]

def selectionOption(sel=[]):
    ''' Entities are collected as three lists: 
     - to edit (actual editing objects), 
     - directed dependencies (objects based on selection),
     - expressions dependencies (dependencies called by expressions) '''

    return {
        '0_obj': {
            'normal': pickSelection(sel, 'addition') + \
                    pickSelection(sel, 'main_base'),
            'toEdit': pickSelection(sel, 'main'),
            'dirDeps': [],
            'exprDeps': pickSelection(sel, 'main_dependency')
            },
        '1_obj_base': {
            'normal': pickSelection(sel, 'addition_base') + \
                    pickSelection(sel, 'main_dependency') + \
                    pickSelection(sel, 'addition'),
            'toEdit': pickSelection(sel, 'main_base'),
            'dirDeps': pickSelection(sel, 'main'),
            'exprDeps': pickSelection(sel, 'main_base_dependency')
            },
        '2_obj_addition': {
            'normal': pickSelection(sel, 'addition_base') + \
                    pickSelection(sel, 'main_base'),
            'toEdit': pickSelection(sel, 'main') + \
                    pickSelection(sel, 'addition'),
            'dirDeps': [],
            'exprDeps': pickSelection(sel, 'main_dependency') + \
                    pickSelection(sel, 'addition_dependency'),
            },
        '3_obj_addition_base': {
            'normal': pickSelection(sel, 'main_dependency'),
            'toEdit': pickSelection(sel, 'main_base') + \
                    pickSelection(sel, 'addition_base'),
            'dirDeps': pickSelection(sel, 'main') + \
                    pickSelection(sel, 'addition'),
            'exprDeps': pickSelection(sel, 'main_base_dependency') + \
                    pickSelection(sel, 'addition_base_dependency'),
            }
    }

selectionVisibility = { ## Attributes for different selection conditions
        'Transparency': {'toEdit': .80, 'dirDeps': .80, 'exprDeps': .80},
        'LineTransparency': {'toEdit': .0, 'dirDeps': .0, 'exprDeps': .0},
        'LineWidth': {'toEdit': 3, 'dirDeps': 1, 'exprDeps': 1},
        'LineColor': {'toEdit': (1.0,1.0,1.0), 'dirDeps': (0.5,0.5,0.5), 
            'exprDeps': (0.0,0.0,0.0)},
        'ShapeColor': {'toEdit': (1.0,1.0,1.0), 'dirDeps': (0.5,0.5,0.5), 
            'exprDeps': (0.0,0.0,0.0)},
        }

hideAttribute = { ## Attributes for temporarily hiding objects
        'Transparency': 100,
        'DisplayMode': 'Wireframe',
        'LineWidth': 1.0
        }

######

class multiGhostTracker(ghostTracker):

    def __init__(self, obj, sep, typ):
        super().__init__(obj)
        self.children = [self.children[0]]
        self.children.append(sep)

        if typ is not 'normal':

            shapeColor = selectionVisibility['ShapeColor']
            lineColor = selectionVisibility['LineColor']
            transparency = selectionVisibility['Transparency']
            lineTransparency = selectionVisibility['LineTransparency']
            lineWidth = selectionVisibility['LineWidth']

            search = coin.SoSearchAction()
            search.setInterest(search.ALL )
            search.setSearchingAll(True)
            SoBaseKit.setSearchingChildren(True)

            variations = {SoIndexedFaceSet: transparency, 
                    SoIndexedLineSet: lineTransparency}

            for sub_ob in variations:
                search.setType(sub_ob.getClassTypeId())
                search.apply(sep)
                paths = search.getPaths()
                for path in paths:
                    if path:
                        parent = path.getNodeFromTail(1)
                        for ch in parent.getChildren():
                            if ch.isOfType(SoMaterial.getClassTypeId()):
                                ch.diffuseColor.getValues()[0].setValue(
                                        lineColor[typ])
                                ch.transparency.setValue(
                                        variations[sub_ob][typ])
                            if ch.isOfType(SoDrawStyle.getClassTypeId()):
                                ch.lineWidth.setValue(lineWidth[typ])

        Tracker.__init__(self,dotted=False,scolor=None,swidth=None,
                children=self.children,name="ghostTracker")

class SelectedObject:
    ''' A class to get all the connection between selected objects and their
    bases, additions and dependencies.'''

    def __init__(self, obj, sel=[], sel_type='main', parent=None):
        self.obj = obj
        self.name = obj.Name
        self.selectionType = sel_type
        if 'Base' in self.obj.PropertiesList and obj.Base:
            self.base = SelectedObject(obj.Base, sel, sel_type + '_base', self)
        ## Create a different SelectedObject with the same obj and if it
        ## is a base yet set parent to none to avoid infinite recursive call
        elif 'base' not in sel_type:
            self.base = SelectedObject(obj, sel, sel_type + '_base', None)
        else:
            self.base = None
        self.parent = parent
        self.additions = []
        self.dependencies = {}
        self.get_attr = lambda name, attr: \
            re.search(name + '\.(.*?)(\s|$)', attr).group(1)
        self.populateAdditions(sel)
        self.populateDependencies(sel)
        self.gui = obj.ViewObject
        self.attr = {attr : getattr(self.gui, attr) for attr in hideAttribute}
        self.ghost = {}
        self.populateGhost()
        if self not in sel:
            sel.append(self)

    def hide(self):
        for attr in hideAttribute:
            setattr(self.gui, attr, hideAttribute[attr])

    def show(self):
        for attr in hideAttribute:
            setattr(self.gui, attr, self.attr[attr])

    def populateDependencies(self, sel):
        for dep in self.obj.InList:
            for pair in dep.ExpressionEngine:
                if self.name + '.' in pair[1]:
                    local_attr = self.get_attr(self.name, pair[1])
                    if local_attr not in self.dependencies:
                        self.dependencies[local_attr] = []
                    self.dependencies[local_attr].append((SelectedObject(dep,
                        sel, self.selectionType + '_dependency'), pair[0]))

    def populateAdditions(self, sel, obj=None):
        if not obj:
            obj = self.obj
        if 'Additions' in obj.PropertiesList and len(obj.Additions) > 0:
            for o in obj.Additions:
                if (o, 'addition') not in [(s.obj, s.selectionType) \
                        for s in sel]:
                    self.additions.append(SelectedObject(o, sel, 'addition'))
                    self.populateAdditions(sel, o)
                else:
                    for s in sel:
                        if s.obj == o and s.selectionType == 'addition':
                            self.additions.append(s)
                            break

    def populateGhost(self):
        ''' Create a ghost for every selection conditions '''
        Gui.Selection.clearSelection()
        ob = self.obj
        visible = ob.ViewObject.Visibility
        tempAdds = []
        if not visible:
            ob.ViewObject.Visibility = True
        if 'Additions' in ob.PropertiesList and len(ob.Additions) > 0:
            tempAdds = ob.Additions
            ob.Additions = []
            App.ActiveDocument.recompute()
        for typ in ['normal', 'toEdit', 'dirDeps', 'exprDeps']:
            separator = self.obj.ViewObject.RootNode.copy()
            self.ghost.update({typ: multiGhostTracker(
                self.obj, separator, typ)})
        if len(tempAdds) > 0:
            ob.Additions += tempAdds
        if not visible:
            ob.ViewObject.Visibility = False


    def report(self):
        print('compiling', self.name)
        if self.base:
            print('base is', self.base.name)
        print('additions are', [a.name for a in self.additions])
        print('dependencies are', [self.dependencies[d][i][0].name for d in \
                self.dependencies for i in range(len(self.dependencies[d]))])

class BaseTransform(Modifier):
    "The Base transform command definition"

    def __init__(self):
        Modifier.__init__(self)
        self.keys = {
                'g': lambda x: Move(x),
                'r': lambda x: Rotate(x),
                's': lambda x: Scale(x),
                }
        self.call_sel = None
        self.call_key = None
        self.call_status = None
        self.selection = []
        self.sel_options = sorted(selectionOption().keys())
        self.sel_opt_no = 0

    def Activated(self):
        self.name = translate("draft","BaseTransform", utf8_decode=True)
        Modifier.Activated(self,self.name)
        if self.ui:
            if not FreeCADGui.Selection.getSelection():
                self.ui.selectUi()
                msg(translate("draft", "Select an object to edit")+"\n")
                self.call_sel = \
                        self.view.addEventCallback("SoEvent", selectObject)
                ## TODO it should allow multiple selections
                ## TODO Ui should be more explanatory
            else:
                self.proceed()

    def proceed(self):
        if self.call_sel:
            self.view.removeEventCallback("SoEvent",self.call_sel)
        self.sel = FreeCADGui.Selection.getSelection()
        self.sel = Draft.getGroupContents(self.sel,addgroups=True,spaces=True,
                noarchchild=True)

        ## self.actual_selection is what the user clicked
        ## self.selection is the actual selection extended to bases, 
        ## additions and dependencies
        self.actual_selection = [SelectedObject(o, self.selection) \
                for o in self.sel]
        print([(o.name, o.selectionType) for o in self.selection])
        print(len(self.selection))

        self.getSelectionSet()

        self.call_key = self.view.addEventCallback(
            "SoKeyboardEvent", self.switch)

    def getSelectionSet(self):
        for so in self.selection:
            for gt in so.ghost:
                if so.ghost[gt].switch:
                    so.ghost[gt].off()
        self.sel_opt_no = (self.sel_opt_no + 1) % len(self.sel_options)
        no  = self.sel_opt_no
        self.possible_selections = selectionOption(self.selection)
        print(self.sel_options[no])
        print(self.possible_selections[self.sel_options[no]])
        self.chosen_selection = self.possible_selections[
                self.sel_options[no]]
        for st in self.chosen_selection:
            for so in self.chosen_selection[st]:
                so.hide()
                so.ghost[st].on()
                if st == 'toEdit':
                    so.ghost[st].raiseTracker()

    def switch(self,info):
        if info['Type'] == 'SoKeyboardEvent' and info['Key'] == 'SPACE' \
                and info['State'] == 'UP' and info['CtrlDown'] == True:
                    print(info['Key'], 'pressed!')
                    self.cycleSelection()
        elif info['Type'] == 'SoKeyboardEvent' and info['Key'] == 'q' \
                and info['State'] == 'UP':
                    print(info['Key'], 'pressed!')
                    self.stopHightlight()
        elif info['Type'] == 'SoKeyboardEvent' and info['Key'] in self.keys \
                and info['State'] == 'UP':
                    print(info['Key'], 'pressed!')
                    self.getTransform(info['Key'])

    def cycleSelection(self):
        Gui.Selection.clearSelection()
        self.getSelectionSet()

    def stopHightlight(self):
        Gui.Selection.clearSelection()
        for so in self.selection:
            for gt in so.ghost:
                if so.ghost[gt].switch:
                    so.ghost[gt].off()
            so.show()
        self.view.removeEventCallback("SoKeyboardEvent", self.call_key)

    def getTransform(self, key):
        self.view.removeEventCallback("SoKeyboardEvent", self.call_key)

        ## Create transformation and activate it
        print(self.chosen_selection)
        self.transform = self.keys[key](self.chosen_selection)
        self.transform.Activated()
        self.call_status = self.view.addEventCallback("SoEvent", self.status)

    def status(self, info):
        if not App.activeDraftCommand:
            ## Transformation completed
            self.view.removeEventCallback("SoEvent", self.call_status)
            print('finished')
            Gui.Selection.clearSelection()
            for so in self.selection:
                #print('so', so)
                so.ghost = {}
                so.show()
            App.activeDocument().recompute()

    def finish(self):
        ## TODO Make sure it finishes when push "Close" or escape
        self.call_sel = None
        self.call_key = None
        self.call_status = None
        Modifier.finish(self)

def replicate(to_edit):
    to_copy = []
    copy_adds = {}
    for sel in to_edit:
        new_obj = App.ActiveDocument.copyObject(sel.obj)
        adds = sel.obj.Additions if 'Additions' in sel.obj.PropertiesList \
                else None
        if adds and len(adds) > 0:
            new_obj.Additions = []
        for attr in hideAttribute:
            setattr(new_obj.ViewObject, attr, sel.attr[attr])
        copy_adds.update({
            sel.obj: {'copy':new_obj, 'additions': adds}})
        to_copy.append(new_obj)
        if sel.parent:
            new_parent = App.ActiveDocument.copyObject(sel.parent.obj)
            if 'Additions' in new_parent.PropertiesList \
                    and len(new_parent.Additions) > 0:
                new_parent.Additions = []
            copy_adds.update({
                sel.parent.obj: {'copy':new_parent, 
                    'additions': sel.parent.obj.Additions}})
            new_parent.Base = new_obj
            for attr in hideAttribute:
                setattr(new_parent.ViewObject, attr, sel.parent.attr[attr])
    print({c.Name: copy_adds[c] for c in copy_adds})
    for o in copy_adds:
        if copy_adds[o]['additions']:
            copy_adds[o]['copy'].Additions = [copy_adds[a]['copy'] \
                    for a in copy_adds[o]['additions'] if a in copy_adds]
    return to_copy

class Move(Modifier):
    "The Draft_Move FreeCAD command definition"

    def __init__(self, sel_dict):
        Modifier.__init__(self)
        self.copymode = False
        self.sel_dict = sel_dict

    def GetResources(self):
        return {'Pixmap'  : 'Draft_Move',
                'Accel' : "M, V",
                'MenuText': QtCore.QT_TRANSLATE_NOOP("Draft_Move", "Move"),
                'ToolTip': QtCore.QT_TRANSLATE_NOOP("Draft_Move",
                    "Moves the selected objects between 2 points. \
                            CTRL to snap, SHIFT to constrain, ALT to copy")}

    def Activated(self):
        self.name = translate("draft","Move", utf8_decode=True)
        Modifier.Activated(self,self.name)
        print('move sel', self.sel_dict)
        self.ghost = {}
        for typ in self.sel_dict:
            if typ not in self.ghost:
                self.ghost.update({typ:[]})
            for o in self.sel_dict[typ]:
                self.ghost[typ].append(o.ghost[typ])
        print('ghost', self.ghost)
        self.proceed()

    def proceed(self):
        if self.call:
            self.view.removeEventCallback("SoEvent",self.call)
        ## TODO check group selection
        #self.sel = Draft.getGroupContents(
        #    self.sel,addgroups=True,spaces=True,noarchchild=True)
        
        self.ui.pointUi(self.name)
        self.ui.modUi()
        if self.copymode:
            self.ui.isCopy.setChecked(True)
        self.ui.xValue.setFocus()
        self.ui.xValue.selectAll()

        self.call = self.view.addEventCallback("SoEvent",self.action)
        msg(translate("draft", "Pick start point:")+"\n")

    def finish(self,closed=False,cont=False):
        if self.ghost:
            for typ in self.ghost:
                for g in [i for i in self.ghost[typ]]:
                    if g.switch:
                        g.off()
                    g.finalize()
        if cont and self.ui:
            if self.ui.continueMode:
                todo.delayAfter(self.Activated,[])
        Modifier.finish(self)

    def move(self,delta,copy=False):
        "moving the real shape's bases"
        FreeCADGui.addModule("Draft")
        sel_to_edit = [o for typ in self.sel_dict \
                for o in self.sel_dict[typ] if typ == 'toEdit']
        if copy:
            obj_to_edit = replicate(sel_to_edit)
        else:
            obj_to_edit = [s.obj for s in sel_to_edit]

        sel = '['
        for o in obj_to_edit:
            if len(sel) > 1:
                sel += ','
            sel += 'FreeCAD.ActiveDocument.' + o.Name
        sel += ']'

        self.commit(translate("draft","Move"),
            ['Draft.move('+sel+','+DraftVecUtils.toString(delta)+ \
                ',copy=False)', 'FreeCAD.ActiveDocument.recompute()'])

    def action(self,arg):
        "scene event handler"
        if arg["Type"] == "SoKeyboardEvent":
            if arg["Key"] == "ESCAPE":
                self.finish()
        elif arg["Type"] == "SoLocation2Event": #mouse movement detection
            #if self.ghost:
            #    self.ghost.off()
            self.point,ctrlPoint,info = getPoint(self,arg)
            if (len(self.node) > 0):
                last = self.node[len(self.node)-1]
                delta = self.point.sub(last)
                if self.ghost:
                    for typ in self.ghost:
                        if typ == 'toEdit' or typ == 'dirDeps':
                            for g in [i for i in self.ghost[typ]]:
                                g.move(delta)
                                g.on()
            if self.extendedCopy:
                if not hasMod(arg,MODALT): self.finish()
            redraw3DView()
        elif arg["Type"] == "SoMouseButtonEvent":
            if (arg["State"] == "DOWN") and (arg["Button"] == "BUTTON1"):
                if self.point:
                    self.ui.redraw()
                    if (self.node == []):
                        self.node.append(self.point)
                        self.ui.isRelative.show()
                        if self.ghost:
                            for typ in self.ghost:
                                for g in [i for i in self.ghost[typ]]:
                                    g.on()
                        msg(translate("draft", "Pick end point:")+"\n")
                        if self.planetrack:
                            self.planetrack.set(self.point)
                    else:
                        last = self.node[0]
                        if self.ui.isCopy.isChecked() or hasMod(arg,MODALT):
                            self.move(self.point.sub(last),True)
                        else:
                            self.move(self.point.sub(last))
                        if hasMod(arg,MODALT):
                            self.extendedCopy = True
                        else:
                            self.finish(cont=True)

    def numericInput(self,numx,numy,numz):
        "this function gets called by the toolbar when valid x, y, and z \
                have been entered there"
        self.point = Vector(numx,numy,numz)
        if not self.node:
            self.node.append(self.point)
            self.ui.isRelative.show()
            self.ui.isCopy.show()
            self.ghost.on()
            msg(translate("draft", "Pick end point:")+"\n")
        else:
            last = self.node[-1]
            if self.ui.isCopy.isChecked():
                self.move(self.point.sub(last),True)
            else:
                self.move(self.point.sub(last))
            self.finish()


class Rotate(Modifier):
    "The Draft_Rotate FreeCAD command definition"

    def __init__(self, sel_dict):
        Modifier.__init__(self)
        self.sel_dict = sel_dict
        self.copies_dict = {}

    def GetResources(self):
        return {'Pixmap'  : 'Draft_Rotate',
                'Accel' : "R, O",
                'MenuText': QtCore.QT_TRANSLATE_NOOP("Draft_Rotate", "Rotate"),
                'ToolTip': QtCore.QT_TRANSLATE_NOOP("Draft_Rotate", 
                    "Rotates the selected objects. CTRL to snap, SHIFT \
                            to constrain, ALT creates a copy")}

    def Activated(self):
        Modifier.Activated(self,"Rotate")
        self.ghost = None
        self.arctrack = None
        self.proceed()

    def proceed(self):
        if self.call:
            self.view.removeEventCallback("SoEvent",self.call)
        self.sel = [b for b in self.sel_dict if type(b) != str] + \
                [self.sel_dict[b] for b in self.sel_dict if type(b) != str]
        self.step = 0
        self.center = None
        self.ui.arcUi()
        self.ui.modUi()
        self.ui.setTitle("Rotate")
        self.arctrack = arcTracker()
        ## Remove selection ot avoid opacity of the ghost
        Gui.Selection.clearSelection()
        self.ghost = ghostTracker(self.sel)
        self.call = self.view.addEventCallback("SoEvent",self.action)
        msg(translate("draft", "Pick rotation center:")+"\n")

    def finish(self,closed=False,cont=False):
        "finishes the arc"
        if self.arctrack:
            self.arctrack.finalize()
        if self.ghost:
            self.ghost.finalize()
        if cont and self.ui:
            if self.ui.continueMode:
                todo.delayAfter(self.Activated,[])
        Modifier.finish(self)
        if self.doc:
            self.doc.recompute()

    def rot (self,angle,copy=False):
        "rotating the real shapes'bases"
        FreeCADGui.addModule("Draft")
        if copy:
            for b in [s for s in self.sel_dict if type(s) != str]:
                copy_object(self.sel_dict[b], self.copies_dict, self.sel_dict)
            to_edit = {k:self.copies_dict[k] for k in self.copies_dict \
                    if type(k) != str}
        else:
            to_edit = {k:self.sel_dict[k] for k in self.sel_dict \
                    if type(k) != str}

        sel = '['
        for o in to_edit:
            if len(sel) > 1:
                sel += ','
            sel += 'FreeCAD.ActiveDocument.'+o.Name
        sel += ']'
            
        self.commit(translate("draft","Rotate"),
            ['Draft.rotate('+sel+','+str(math.degrees(angle))+','+ \
                    DraftVecUtils.toString(self.center)+',axis='+ \
                    DraftVecUtils.toString(plane.axis)+',copy=False)'])
        for o in to_edit:
            ob = to_edit[o]
            ## TODO extend to other types of arch objects
            if ob.Proxy.__module__ == 'ArchWall':
                normal = normalizeNormal(ob) 
                rotatedNormal = DraftVecUtils.rotate(normal,angle,plane.axis)
                ob.Normal = rotatedNormal
                App.activeDocument().recompute()

    def action(self,arg):
        "scene event handler"
        if arg["Type"] == "SoKeyboardEvent":
            if arg["Key"] == "ESCAPE":
                self.finish()
        elif arg["Type"] == "SoLocation2Event":
            if self.ghost:
                self.ghost.off()
            self.point,ctrlPoint,info = getPoint(self,arg)
            # this is to make sure radius is what you see on screen
            if self.center and DraftVecUtils.dist(self.point,self.center):
                viewdelta = DraftVecUtils.project(self.point.sub(self.center),
                        plane.axis)
                if not DraftVecUtils.isNull(viewdelta):
                    self.point = self.point.add(viewdelta.negative())
            if self.extendedCopy:
                if not hasMod(arg,MODALT):
                    self.step = 3
                    self.finish()
            if (self.step == 0):
                pass
            elif (self.step == 1):
                currentrad = DraftVecUtils.dist(self.point,self.center)
                if (currentrad != 0):
                    angle = DraftVecUtils.angle(plane.u,
                            self.point.sub(self.center), plane.axis)
                else: angle = 0
                self.ui.setRadiusValue(math.degrees(angle),unit="Angle")
                self.firstangle = angle
                self.ui.radiusValue.setFocus()
                self.ui.radiusValue.selectAll()
            elif (self.step == 2):
                currentrad = DraftVecUtils.dist(self.point,self.center)
                if (currentrad != 0):
                    angle = DraftVecUtils.angle(plane.u, 
                            self.point.sub(self.center), plane.axis)
                else: angle = 0
                if (angle < self.firstangle):
                    sweep = (2*math.pi-self.firstangle)+angle
                else:
                    sweep = angle - self.firstangle
                self.arctrack.setApertureAngle(sweep)
                if self.ghost:
                    self.ghost.rotate(plane.axis,sweep)
                    self.ghost.on()
                self.ui.setRadiusValue(math.degrees(sweep), 'Angle')
                self.ui.radiusValue.setFocus()
                self.ui.radiusValue.selectAll()
            redraw3DView()

        elif arg["Type"] == "SoMouseButtonEvent":
            if (arg["State"] == "DOWN") and (arg["Button"] == "BUTTON1"):
                if self.point:
                    if (self.step == 0):
                        self.center = self.point
                        self.node = [self.point]
                        self.ui.radiusUi()
                        self.ui.radiusValue.setText(FreeCAD.Units.Quantity(
                            0,FreeCAD.Units.Angle).UserString)
                        self.ui.hasFill.hide()
                        self.ui.labelRadius.setText("Base angle")
                        self.arctrack.setCenter(self.center)
                        if self.ghost:
                            self.ghost.center(self.center)
                        self.step = 1
                        msg(translate("draft", "Pick base angle:")+"\n")
                        if self.planetrack:
                            self.planetrack.set(self.point)
                    elif (self.step == 1):
                        self.ui.labelRadius.setText("Rotation")
                        self.rad = DraftVecUtils.dist(self.point,self.center)
                        self.arctrack.on()
                        self.arctrack.setStartPoint(self.point)
                        if self.ghost:
                            self.ghost.on()
                        self.step = 2
                        msg(translate("draft", "Pick rotation angle:")+"\n")
                    else:
                        currentrad = DraftVecUtils.dist(self.point,self.center)
                        angle = self.point.sub(self.center).getAngle(plane.u)
                        if DraftVecUtils.project(self.point.sub(self.center), 
                                plane.v).getAngle(plane.v) > 1:
                            angle = -angle
                        if (angle < self.firstangle):
                            sweep = (2*math.pi-self.firstangle)+angle
                        else:
                            sweep = angle - self.firstangle
                        if self.ui.isCopy.isChecked() or hasMod(arg,MODALT):
                            self.rot(sweep,True)
                        else:
                            self.rot(sweep)
                        if hasMod(arg,MODALT):
                            self.extendedCopy = True
                        else:
                            self.finish(cont=True)

    def numericInput(self,numx,numy,numz):
        "this function gets called by the toolbar when valid x, y, and z \
                have been entered there"
        self.center = Vector(numx,numy,numz)
        self.node = [self.center]
        self.arctrack.setCenter(self.center)
        if self.ghost:
            self.ghost.center(self.center)
        self.ui.radiusUi()
        self.ui.hasFill.hide()
        self.ui.labelRadius.setText("Base angle")
        self.step = 1
        msg(translate("draft", "Pick base angle:")+"\n")

    def numericRadius(self,rad):
        "this function gets called by the toolbar when valid radius have \
                been entered there"
        if (self.step == 1):
            self.ui.labelRadius.setText("Rotation")
            self.firstangle = math.radians(rad)
            self.arctrack.setStartAngle(self.firstangle)
            self.arctrack.on()
            if self.ghost:
                self.ghost.on()
            self.step = 2
            msg(translate("draft", "Pick rotation angle:")+"\n")
        else:
            self.rot(math.radians(rad),self.ui.isCopy.isChecked())
            self.finish(cont=True)


class Scale(Modifier):
    '''The Draft_Scale FreeCAD command definition.
    This tool scales the selected objects from a base point.'''

    def __init__(self, sel_dict):
        Modifier.__init__(self)
        self.sel_dict = sel_dict
        self.copies_dict = {}

    def GetResources(self):
        return {'Pixmap'  : 'Draft_Scale',
                'Accel' : "S, C",
                'MenuText': QtCore.QT_TRANSLATE_NOOP("Draft_Scale", "Scale"),
                'ToolTip': QtCore.QT_TRANSLATE_NOOP("Draft_Scale", 
                    "Scales the selected objects from a base point. \
                            CTRL to snap, SHIFT to constrain, ALT to copy")}

    def Activated(self):
        self.name = translate("draft","Scale", utf8_decode=True)
        Modifier.Activated(self,self.name)
        self.ghost = None
        self.proceed()

    def proceed(self):
        if self.call:
            self.view.removeEventCallback("SoEvent",self.call)
        self.sel = [b for b in self.sel_dict if type(b) != str] + \
                [self.sel_dict[b] for b in self.sel_dict if type(b) != str]
        self.refs = []
        self.ui.pointUi(self.name)
        self.ui.modUi()
        self.ui.xValue.setFocus()
        self.ui.xValue.selectAll()
        ## Remove selection ot avoid opacity of the ghost
        Gui.Selection.clearSelection()
        self.ghost = ghostTracker(self.sel)
        self.pickmode = False
        self.task = None
        self.call = self.view.addEventCallback("SoEvent",self.action)
        msg(translate("draft", "Pick base point:")+"\n")

    def pickRef(self):
        self.pickmode = True
        if self.node:
            self.node = self.node[:1] # remove previous picks
        msg(translate("draft", "Pick reference distance from base point:")+"\n")
        self.call = self.view.addEventCallback("SoEvent",self.action)

    def finish(self,closed=False,cont=False):
        Modifier.finish(self)
        if self.ghost:
            self.ghost.finalize()

    def scale(self,x,y,z,rel,mode):
        delta = Vector(x,y,z)
        if rel:
            delta = FreeCAD.DraftWorkingPlane.getGlobalCoords(delta)
        if mode == 0:
            copy = False
            legacy = False
        elif mode == 1:
            copy = False
            legacy = True
        elif mode == 2:
            copy = True
            legacy = True
        "moving the real shapes"
        FreeCADGui.addModule("Draft")
        if copy:
            for b in self.sel_dict:
                if type(b) != str:
                    copy_object(self.sel_dict[b], self.copies_dict,
                            self.sel_dict)
        to_edit = self.copies_dict if copy else \
                {k:self.sel_dict[k] for k in self.sel_dict if type(k) != str}

        ## TODO handle arch object parameters
        sel = '['
        for o in to_edit:
            if len(sel) > 1:
                sel += ','
            sel += 'FreeCAD.ActiveDocument.'+o.Name
        sel += ']'

        self.commit(translate("draft","Copy"),
                    ['Draft.scale('+sel+',delta='+ \
                            DraftVecUtils.toString(delta)+',center='+ \
                            DraftVecUtils.toString(self.node[0])+ \
                            ',copy=False,legacy='+str(legacy)+')',
                     'FreeCAD.ActiveDocument.recompute()'])
        self.finish()

    def scaleGhost(self,x,y,z,rel):
        delta = Vector(x,y,z)
        if rel:
            delta = FreeCAD.DraftWorkingPlane.getGlobalCoords(delta)
        self.ghost.scale(delta)
        # calculate a correction factor depending on the scaling center
        corr = Vector(self.node[0].x,self.node[0].y,self.node[0].z)
        corr.scale(delta.x,delta.y,delta.z)
        corr = (corr.sub(self.node[0])).negative()
        self.ghost.move(corr)
        self.ghost.on()

    def action(self,arg):
        "scene event handler"
        if arg["Type"] == "SoKeyboardEvent":
            if arg["Key"] == "ESCAPE":
                self.finish()
        elif arg["Type"] == "SoLocation2Event": #mouse movement detection
            if self.ghost:
                self.ghost.off()
            self.point,ctrlPoint,info = getPoint(self,arg,sym=True)
        elif arg["Type"] == "SoMouseButtonEvent":
            if (arg["State"] == "DOWN") and (arg["Button"] == "BUTTON1"):
                if self.point:
                    #self.ui.redraw()
                    self.numericInput(self.point.x,self.point.y,self.point.z)

    def numericInput(self,numx,numy,numz):
        "this function gets called by the toolbar when a valid base point \
                has been entered"
        self.point = Vector(numx,numy,numz)
        self.node.append(self.point)
        if not self.pickmode:
            self.ui.offUi()
            if self.call:
                self.view.removeEventCallback("SoEvent",self.call)
            self.task = DraftGui.ScaleTaskPanel()
            self.task.sourceCmd = self
            DraftGui.todo.delay(FreeCADGui.Control.showDialog,self.task)
            if self.ghost:
                self.ghost.on()
        elif len(self.node) == 2:
            msg(translate("draft", "Pick new distance from base point:")+"\n")
        elif len(self.node) == 3:
            if hasattr(FreeCADGui,"Snapper"):
                FreeCADGui.Snapper.off()
            if self.call:
                self.view.removeEventCallback("SoEvent",self.call)
            d1 = (self.node[1].sub(self.node[0])).Length
            d2 = (self.node[2].sub(self.node[0])).Length
            #print d2,"/",d1,"=",d2/d1
            if hasattr(self,"task"):
                if self.task:
                    self.task.lock.setChecked(True)
                    self.task.setValue(d2/d1)


bt = BaseTransform()
bt.Activated()


def traverse_structure():
    sg = FreeCADGui.ActiveDocument.ActiveView.getSceneGraph()
    obj = App.ActiveDocument.Structure
    sep = coin.SoSeparator()
    col = coin.SoBaseColor()
    col.rgb=(1,0,0)
    objNode = obj.ViewObject.RootNode.copy()
    for fi in objNode.getChildren():
        print(fi)
        if (fi.getChildren()):
            for ffi in fi.getChildren():
                print('\t', ffi)
                if (ffi.getChildren()):
                    for fffi in ffi.getChildren():
                        print('\t\t', fffi)
                        if (fffi.getChildren()):
                            for ffffi in fffi.getChildren():
                                #if ffffi.isOfType(SoMaterial.getClassTypeId()):
                                    #print('°°°°°°°°°°°°°°°°°°°°°')
                                    #print(ffffi.diffuseColor.getValues()[0].getValue())
                                    #ffffi.diffuseColor.getValues()[0].setValue(
                                            #1.0,1.0,0.0)
                                    #ffffi.transparency.setValue(.5)
                                print('\t\t\t', ffffi)
                                if (ffffi.getChildren()):
                                    for fffffi in ffffi.getChildren():
                                        print('\t\t\t\t', fffffi)
    search = coin.SoSearchAction()

    search.setInterest(search.ALL )
    search.setSearchingAll(True)
    coin.SoBaseKit.setSearchingChildren(True)

    #search.setType(SoMaterial.getClassTypeId())
    search.setType(SoIndexedLineSet.getClassTypeId())
    search.apply(objNode)
    paths = search.getPaths()
    numPaths = paths.getLength()
    print('paths are', numPaths)
    print('\n\n\n')
    for path in paths:
        print(path.getTail())
        print('sibling of')
        parent = path.getNodeFromTail(1)
        for ch in parent.getChildren():
            print(ch)
        print('\n\n\n')
    #    path.getTail().diffuseColor.getValues()[0].setValue(1.0,1.0,0.0)
    #    path.getTail().transparency.setValue(.8)
    print('\n\n\n')

    #sg.addChild(objNode)

traverse_structure()

## 
## 
## sep.addChild(objNode)
## #sep.getChildren()[0].addChild(col)
## #node = coin.SoAnnotation()
## #node.addChild(col)
## #node.addChild(sep)
## sg.addChild(sep)
## #print([ch for ch in sep.getChildren()[0]])
## #print([ch for ch in sep.getChildren()[0][2]])
## search = coin.SoSearchAction()
## search.setType(SoIndexedFaceSet.getClassTypeId())
## search.apply(sep)
## print(search.getPath())
## sg.removeChild(sep)
## 
## #sg = FreeCADGui.ActiveDocument.ActiveView.getSceneGraph()
## #col = coin.SoBaseColor()
## #col.rgb=(1,0,0)
## #trans = coin.SoTranslation()
## #trans.translation.setValue([0,0,0])
## #transform = coin.SoTransform()
## #cub = coin.SoCube()
## #myCustomNode = coin.SoSeparator()
## #myCustomNode.addChild(col)
## #myCustomNode.addChild(trans)
## #myCustomNode.addChild(cub)
## #sg.addChild(myCustomNode)
## #sg.removeChild(myCustomNode)
## 
## #search = coin.SoSearchAction()
## #search.setType(SoCube.getClassTypeId())
## #search.apply(sg)
## #print(search.getPath())
## #for o in sg.getChildren():
## #    print(o)
## #    if o.getChildren():
## #        for ch in o.getChildren():
## #            if ch.isOfType(SoCube.getClassTypeId()):
## #                print('\t', ch)
## #                #print('\t', dir(ch.getClassTypeId()))
## #                #print('\t', ch.getTypeId())
## #                #print('\t', ch.getTypeId().getName(), type(ch.getTypeId().getName()))
